/**
  This file contains a grammar for llf.
  @author Yaoshiang Ho
*/

options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Parser) 
import java.io.*;

/**
   The parser class.  Most parsing mechanics will be generated by
   javacc 0.7.1.

   This parser uses the official grammar spec as a basis for all
   constructions.  However, MAJOR modifications occured, generally
   for these reasons.  

   First, JavaCC is a LL(k) parser, not LALR like yacc/bison.  
   Hence, left recursion must be removed.  Note that left associative
   operators introduce left recursion, because the rules essentially
   tranform into:  M ::= [ M ] <operator> <something other than M>.

   Second, precedence is introduced by creating non-terminals for every
   predecedence level.  So, for example, in the grammar, the non-terminal
   M (Base Object) can be an Additive Pair, or a lamda function.  One
   non-terminal is created for each possibility.
*/

public class Parser {

  static final String crlf = System.getProperty("line.separator");

  public static String[] space;

  public static Parser create(java.io.InputStream is) {
    return new Parser(is);
  }

  public static Parser create(String s) {
    char[] ca = s.toCharArray();
    byte[] ba = new byte[ca.length];

    for (int i=0; i<ca.length; ++i) {
      ba[i] = (byte) ca[i];
    }

    ByteArrayInputStream bais = new ByteArrayInputStream(ba);

    return new Parser (bais);
  }

  public static void initSpaces(int max) {
    char[] spacesSlave = "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ".toCharArray();

    space = new String[max];

    for (int i=0; i<max; ++i) {
      space[i] = new String(spacesSlave, 0, i);
    }
  }

  static {
    Parser.initSpaces(2048);
  }

}
PARSER_END(Parser)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  < TOP:	"<T>">
| < UNIT: 	"()">

| < WITH:	"&">

| < RLOLLIPOP:	"-o">
| < LLOLLIPOP:	"o-">
| < RARROW:	"->">
| < LARROW:	"<-">

| < LPAREN: 	"(" >
| < RPAREN: 	")" >
| < LBRACE: 	"{" >
| < RBRACE: 	"}" >
| < LBRACKET: 	"[" >
| < RBRACKET: 	"]" >

| < COLON:	":" >
| < COMMA:	"," >
| < HAT:	"^">
| < FIRST:	"<fst>" >
| < SECOND: 	"<snd>" >
}

// Names of variables, constants, and type family constants.

TOKEN :
{
  < IDENTIFIER:  (<LETTER>|<DIGIT>|<OTHER>)+ >
|
  < #LETTER:
      [
       "a"-"z",
       "A"-"Z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >
|
  < #OTHER:
    [
     "!", "@", "#", "$", "%", "*", 
     "_", "-", "+", "=", "|", "\\", "~", "`",
     ";", "\"", "'",     
     "/", "?",
     "."
    ]
  >
}

//
// The actual Grammar follows:
//

BaseObject
root() :
{
  BaseObject bo;
}
{
  bo=baseObject() <EOF> 
	{
	  return bo;
	}
}

BaseObject 
baseObject() :
{
  BaseObject bo;
}
{
  bo=commaBaseObject()
	{
	  return bo;
	}
}

BaseObject 
commaBaseObject() :
{
  Token c = null;

  Variable v = null;
  Type t = null;
  BaseObject bo = null;

  BaseObject lbo = null;
  BaseObject rbo = null;

}
{
  lbo=lambdaBaseObject() [ <COMMA> rbo=commaBaseObject() ]
	{
	  if (null == rbo) {
	    return lbo;
	  } else {
	    return new Pair(lbo, rbo);
 	  }
	}
}

BaseObject
lambdaBaseObject() :
{
  BaseObject bo = null;

  Variable v = null;

  Type t = null;

  Token token = null;
}
/**
  Base objects of type lambda.

  WARNING: You must replace the string literal "^" if you modify the 
           token <HAT>.
*/
{
  (
  <LBRACKET> v=variable() (token=<HAT>|token=<COLON>) t=type() <RBRACKET> bo=lambdaBaseObject()
	{
	  if ("^".equals(token.image)) {
	    return new LinearLambda(v, t, bo);
	  } else {
	    return new Lambda(v, t, bo);
	  }
        }
  )

|  
  (
  bo=functionBaseObject() 
  	{
	  return bo;
	}
  )

}

BaseObject
functionBaseObject() :
{
  BaseObject lbo = null;
  BaseObject rbo = null;

  java.util.Vector v;

  BaseObject retval;
}
/**
  An App or LinearApp base object.

  A little trick is used here to make the expression left associative.
  Remeber that JavaCC is an LL(k) parser, so it can not handle left recursion.

  We use the helper method functionBaseObjectVector to create a vector
  of pairingBaseObjects (which are one level higher in precedence than
  App and LinearApp).  Then we iterate through the vector, creating the
  correct predecence.

  @see functionBaseObjectVector
*/
{
  v=functionBaseObjectVector()
    	{
	  if (0 == v.size()) {
	    throw new ParseException("Assertion failed.  Size of v should be a positive, odd number.");
	  }

	  retval = (BaseObject) v.elementAt(0);

	  for (int i=1; i<v.size(); i += 2) {
	    String s = 		(String) v.elementAt(i);
	    BaseObject bo = 	(BaseObject) v.elementAt(i+1);

	    if (" ".equals(s)) {
	      retval = new App(retval, bo);
	    } else {
	      // s must equal "^".
	      retval = new LinearApp(retval, bo);
	    } 
	  }
	  return retval;
	}
}

java.util.Vector
functionBaseObjectVector() :
{
  BaseObject lbo = null;
  BaseObject rbo = null;
  
  java.util.Vector retval = null;
  
  Token token = null;
}
/**
  A helper method to create left associativity in function base objects.

  WARNING: You must replace the string literal " " if you modify the 
	   production for an Intiutionistic Function Application.
*/
{
  (
   lbo=highestBaseObject() [LOOKAHEAD(2)[token=<HAT>] retval=functionBaseObjectVector() ]
	{
	  if (null == retval) {
	    retval = new java.util.Vector();
	    retval.addElement(lbo);
	  } else {
	    retval.insertElementAt(lbo, 0);
	    retval.insertElementAt((null==token) ? " " : token.image, 1);
	  }
	  
	  return retval;
	}
  )
}

BaseObject 
highestBaseObject() :
{
  Token c;
  BaseObject bo;
}
/**
  The base objects with the highest precedence.
  
*/
{
  (
  <FIRST> bo=highestBaseObject()
	{
          return new First(bo);
	}

  )
|
  (
  <SECOND> bo=highestBaseObject()
	{
	  return new Second(bo);
	}

  )
|
  (
  <LPAREN> bo=baseObject() <RPAREN>
	{
	  return bo;
	}
  )
|
  (
  c=<IDENTIFIER> 
	{ 
	  return new Identifier(c.image); 
	}
  )
|
  (
  <UNIT>
	{
	  return new Unit();
	}
  )
}

TypeFamily 
typeFamily() : 
{
  Token c;
 
  BaseObject bo = null; 

  java.util.Vector v = new java.util.Vector();
}
/**
   This method follows the Red Dragon book, page 176, in it's method
   of removing left recursion.
 */
{
  (
  c=<IDENTIFIER> [v=typeFamilyVector()]
	{
	  TypeFamily retval;

	  retval = new TypeFamilyConstant(c.image);

	  for (int i=0; i<v.size(); i++) {
	    retval = new TypeFamilyInstantiation(retval, 
						 (BaseObject) v.elementAt(i));
	  }
	  return retval;
	}
  )

}

java.util.Vector
typeFamilyVector() :
{
  BaseObject bo = null;
  java.util.Vector retval = null;
}
{
  bo=baseObject2() [retval=typeFamilyVector()]
	{
	  if (null == retval) {
	    retval = new java.util.Vector();
	    retval.addElement(bo);
	    return retval;
	  } else {
	    retval.insertElementAt(bo, 0);
	    return retval;
	  }
	}
}

Type
type() :
{
  Type t;
} 
{
  t=functionType()
	{
	  return t;
	}
}

Type
functionType() :
{
  Type lt;
  Type rt;

  Variable v;
}
{
  (
   <LBRACE> v=variable() <COLON> lt=functionType() <RBRACE> rt=functionType()
	{
	  return new FunctionType(v, lt, rt);
	}
  )
|
  (
   lt=leftFunctionType() 
	{
	  return lt;
	}
  )  
}

Type
leftFunctionType() :
{
  java.util.Vector v;

  Type retval;
}
/**
  A left lollipop or left arrow.

  WARNING: You must replace the string literals "o-" and "<-" if you
   	   modify the left lollipop or left arrow.
*/
{
  v=leftFunctionTypeVector()
	{
	  if (0 == v.size()) {
	    throw new ParseException("Assertion failed.  Size of v should be a positive, odd number.");
	  }

	  retval = (Type) v.elementAt(v.size()-1);

	  for (int i=v.size()-2; i>=0; i-=2) {
	    String s =		(String) v.elementAt(i);
	    Type t  = 		(Type) v.elementAt(i-1);

	    // Notice that retval is recursing down the left.  That is
	    // the essence of how o- is being reversed into a -o.

	    // Associativity, on the other hand, is being reversed from
	    // left to right by the reverse direction of this for loop.

	    if ("o-".equals(s)) {
	      retval = new Lollipop(retval, t);
   	    } else {
	      // s must equal "<-".
	      retval = new FunctionType(null, retval, t);
  	    } 
	  }
	  return retval;

	}
}

java.util.Vector
leftFunctionTypeVector() :
{
  Type lt = null;
  Type rt = null;

  java.util.Vector retval = null;

  Token t = null;
}
{
  lt = rightFunctionType() [ (t=<LLOLLIPOP>|t=<LARROW>) retval=leftFunctionTypeVector()]
	{
	  if (null == retval) {
	    retval = new java.util.Vector();
	    retval.addElement(lt);
	  } else {
	    retval.insertElementAt(lt, 0);
	    retval.insertElementAt(t.image, 1);
	  }
	  
	  return retval;
	}
}

Type
rightFunctionType() :
{
  Type lt = null;
  Type rt = null;

  Token t = null;
}
/**
  A right lollipop or right arrow.

  WARNING: You must replace the string literals "-o" and "->" if you
   	   modify the production for right lollipop or right arrow.
*/
{
  lt=withType() [(t=<RLOLLIPOP>|t=<RARROW>) rt=rightFunctionType()]
	{
	  if (null == rt) {
	    return lt;
	  } else if ("-o".equals(t.image)) {
	    return new Lollipop(lt, rt);
	  } else if ("->".equals(t.image)) {
	    return new FunctionType(null, lt, rt);
	  }
	}
}

Type
withType() :
{
  Type lt = null;
  Type rt = null;
}
{
  lt=highestType() [<WITH> rt=withType()]
	{
	  if (null == rt) {
	    return lt;
	  } else {
	    return new With(lt, rt);
	  }
	}
}

Type
highestType() :
{
  TypeFamily tf;
  Type t;
}
{
  (
   tf=typeFamily()
	{
	  return tf;
	}
  )  
|
  (
   <TOP>
	{
	  return new Top();
	}
  )
|
  (
  <LPAREN> t=type() <RPAREN>
	{
	  return t;
	}
  )
}

Variable
variable() :
{
  Token t;
}
{
  (
  t=<IDENTIFIER> 
	{
	  return new Variable(t.image);
	}
  )
}



///////////////////////////////////////////////////////////////////////////
BaseObject 
baseObject2() :
{
  BaseObject bo;
}
{
  bo=commaBaseObject2()
	{
	  return bo;
	}
}

BaseObject 
commaBaseObject2() :
{
  Token c = null;

  Variable v = null;
  Type t = null;
  BaseObject bo = null;

  BaseObject lbo = null;
  BaseObject rbo = null;

}
{
  lbo=lambdaBaseObject2() [ <COMMA> rbo=commaBaseObject2() ]
	{
	  if (null == rbo) {
	    return lbo;
	  } else {
	    return new Pair(lbo, rbo);
 	  }
	}
}

BaseObject
lambdaBaseObject2() :
{
  BaseObject bo = null;

  Variable v = null;

  Type t = null;

  Token token = null;
}
/**
  Base objects of type lambda.

  WARNING: You must replace the string literal "^" if you modify the 
           token <HAT>.
*/
{
  (
  <LBRACKET> v=variable() (token=<HAT>|token=<COLON>) t=type() <RBRACKET> bo=lambdaBaseObject2()
	{
	  if ("^".equals(token.image)) {
	    return new LinearLambda(v, t, bo);
	  } else {
	    return new Lambda(v, t, bo);
	  }
        }
  )

|  
  (
  bo=highestBaseObject2() 
  	{
	  return bo;
	}
  )

}

BaseObject 
highestBaseObject2() :
{
  Token c;
  BaseObject bo;
}
/**
  The base objects with the highest precedence.
  
*/
{
  (
  <FIRST> bo=highestBaseObject2()
	{
          return new First(bo);
	}

  )
|
  (
  <SECOND> bo=highestBaseObject2()
	{
	  return new Second(bo);
	}

  )
|
  (
  <LPAREN> bo=baseObject() <RPAREN>
	{
	  return bo;
	}
  )
|
  (
  c=<IDENTIFIER> 
	{ 
	  return new Identifier(c.image); 
	}
  )
|
  (
  <UNIT>
	{
	  return new Unit();
	}
  )
}
